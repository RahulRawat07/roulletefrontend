import { Sprite } from "pixi.js";
import { Globals } from "./globals";
import { Scene } from "./scene";
import { RoulleteBoard } from "./roullete";
import { SpinMessage, RoundStartMessage, GameStateMessage } from "./WebSocketService";

// Import modular components
import { BallPhysics } from "./physics/BallPhysics";
import { GameUI } from "./ui/GameUI";
import { GameNetworkManager } from "./network/GameNetworkManager";
import { InputController } from "./controls/InputController";
import { WheelSynchronizer } from "./sync/WheelSynchronizer";
import { ROULETTE_CONFIG } from "./config/GameConfig";


/**
 * üéØ Main Scene - Game Orchestrator
 * Coordinates all game systems and manages their interactions
 */
export class MainScene extends Scene {
    // Core game components
    private roulette: RoulleteBoard = new RoulleteBoard();
    private ball!: Sprite;
    
    // Modular systems
    private ballPhysics!: BallPhysics;
    private gameUI!: GameUI;
    private networkManager!: GameNetworkManager;
    private inputController!: InputController;
    private wheelSync!: WheelSynchronizer;
    
    // Game state
    private isSpinning: boolean = false;


    constructor() {
        super(false);
        const rouletteBoard = new Sprite(Globals.resources.table);
        rouletteBoard.anchor.set(0.5);

        this.mainContainer.addChild(rouletteBoard);
        rouletteBoard.scale.set(1);
        rouletteBoard.position.set(window.innerWidth/2 + rouletteBoard.width/12, window.innerHeight/2+rouletteBoard.height/4);
        rouletteBoard.alpha = 0.1;
        // rouletteBoard.blendMode = 'multiply';
        this.initializeScene();
        this.initializeSystems();
        this.connectSystems();
        this.startCountdown(60, () => {
            console.log("Countdown finished!");
        });
        console.log("üéØ MainScene orchestrator initialized");
    }

    /**
     * üéÆ Initialize core scene components
     */
    private initializeScene(): void {
        // Add roulette board to scene
        this.mainContainer.addChild(this.roulette);
        
        // Create ball sprite
        this.ball = new Sprite(Globals.resources.ball);
        this.mainContainer.addChild(this.ball);
        
        console.log("üéÆ Core scene components initialized");
    }

    /**
     * üîß Initialize all modular systems
     */
    private initializeSystems(): void {
        // Initialize ball physics system
        this.ballPhysics = new BallPhysics(this.ball, this.roulette, {
            onSpinComplete: (winningNumber: number) => this.handleSpinComplete(winningNumber),
            onBallLanded: (winningNumber: number) => this.handleBallLanded(winningNumber),
            onPhaseChanged: (phase: string, progress: number) => this.handlePhaseChanged(phase, progress)
        });

        // Initialize UI system
        this.gameUI = new GameUI(this.mainContainer, {
            onCountdownComplete: () => this.handleCountdownComplete()
        });

        // Initialize network system
        this.networkManager = new GameNetworkManager({
            onConnected: () => this.handleNetworkConnected(),
            onDisconnected: () => this.handleNetworkDisconnected(),
            onError: (error) => this.handleNetworkError(error),
            onGameState: (message) => this.handleGameState(message),
            onRoundStart: (message) => this.handleRoundStart(message),
            onServerSpin: (message) => this.handleServerSpin(message)
        });

        // Initialize input system
        this.inputController = new InputController(this.mainContainer, {
            onSpin: (targetNumber) => this.handleInputSpin(targetNumber),
            onRandomSpin: () => this.handleInputRandomSpin(),
            onCountdownStart: (seconds) => this.handleInputCountdownStart(seconds),
            onCountdownStop: () => this.handleInputCountdownStop()
        });

        // Initialize wheel synchronizer
        this.wheelSync = new WheelSynchronizer(this.roulette);

        console.log("üîß All modular systems initialized");
    }

    /**
     * üîó Connect systems and start operations
     */
    private connectSystems(): void {
        // Start wheel rotation
        this.wheelSync.startConstantRotation();
        
        // Connect to network
        this.networkManager.connectToServer();
        
        // Log controls
        this.inputController.logControls();
        
        console.log("üîó Systems connected and operational");
    }

    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    // üéæ BALL PHYSICS EVENT HANDLERS
    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    private handleSpinComplete(winningNumber: number): void {
        this.isSpinning = false;
        this.updateGameState();
        
        // Check actual winner
        const actualWinner = this.roulette.getCurrentWinningNumber();
        
        console.log(`üéâ Spin complete! Target: ${winningNumber}, Actual: ${actualWinner}`);
        
        if (actualWinner === winningNumber) {
            console.log("‚úÖ PERFECT LANDING!");
        } else {
            console.warn(`‚ùå ALIGNMENT MISMATCH: Expected ${winningNumber}, Got ${actualWinner}`);
            this.roulette.debugWheelState();
        }

        // üîß FIX: No need to restart wheel - it never stops in real casino mode
        console.log("üé∞ Wheel continues constant rotation - ready for next spin immediately");

        // Start countdown for next round (manual mode only)
        if (!Globals.isProd) {
            Globals.gsap?.delayedCall(1.5, () => {
                console.log("üé∞ Manual mode: Starting countdown for next round...");
                this.gameUI.startCountdown(ROULETTE_CONFIG.autoCountdownDuration, () => {
                    console.log("‚è∞ Countdown finished! You can spin again!");
                });
            });
        } else {
            console.log("üåê Server mode: Waiting for server to control next round timing.");
        }
    }

    private handleBallLanded(winningNumber: number): void {
        console.log(`üéæ Ball landed on number ${winningNumber}!`);
        // Future: Add visual effects, sounds, etc.
    }

    private handlePhaseChanged(phase: string, progress: number): void {
        console.log(`üé¨ Ball physics phase: ${phase} (${(progress * 100).toFixed(1)}%)`);
        
        // You can add visual feedback here based on the phase
        // For example, update UI to show current animation phase
        
    }

    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    // üé® UI EVENT HANDLERS
    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    private handleCountdownComplete(): void {
        console.log("‚è∞ UI countdown completed");
        this.updateGameState();
    }

    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    // üåê NETWORK EVENT HANDLERS
    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    private handleNetworkConnected(): void {
        this.gameUI.updateConnectionStatus('CONNECTED');
        this.updateGameState();
        console.log("üåê Network connected - server mode activated");
    }

    private handleNetworkDisconnected(): void {
        this.gameUI.updateConnectionStatus('DISCONNECTED');
        this.updateGameState();
        console.log("üåê Network disconnected - manual mode activated");
    }

    private handleNetworkError(error: any): void {
        this.gameUI.updateConnectionStatus('ERROR');
        console.error("üåê Network error:", error);
    }

    private handleGameState(message: GameStateMessage): void {
        console.log(`üéÆ Game state received:`, message);
        
        if (message.roundActive && message.timeLeft > 0) {
            // Stop any current spin
            if (this.isSpinning) {
                this.ballPhysics.stopAllAnimations();
                this.isSpinning = false;
                this.updateGameState();
            }

            // Sync countdown with server
            const seconds = Math.ceil(message.timeLeft / 1000);
            this.gameUI.startCountdown(seconds, () => {
                console.log('‚è∞ Synced countdown finished! Waiting for server spin...');
            });
        } else {
            console.log('üí§ Server is in waiting state');
            this.gameUI.stopCountdown();
        }

        this.gameUI.updateConnectionStatus('CONNECTED');
    }

    private handleRoundStart(message: RoundStartMessage): void {
        console.log(`üïí Round started! ${message.timeLeft}ms remaining`);
        
        // Stop any current spin
        if (this.isSpinning) {
            this.ballPhysics.stopAllAnimations();
            this.isSpinning = false;
            this.updateGameState();
        }

        // Start countdown with server time
        const seconds = Math.ceil(message.timeLeft / 1000);
        this.gameUI.startCountdown(seconds, () => {
            console.log('‚è∞ Server countdown finished! Waiting for spin...');
        });
    }

    private handleServerSpin(message: SpinMessage): void {
        console.log(`üé∞ Server spin received! Target INDEX: ${message.index}`);
        
        // üîß FIX: Convert server index to actual number
        const rouletteNumbers = this.roulette.getRouletteNumbers();
        const targetNumber = rouletteNumbers[message.index];
        
        if (targetNumber === undefined) {
            console.error(`‚ùå Invalid server index: ${message.index}. Valid range: 0-${rouletteNumbers.length - 1}`);
            return;
        }
        
        console.log(`üéØ Converted server index ${message.index} to target number ${targetNumber}`);
        
        // Stop countdown and execute spin with the actual number
        this.gameUI.stopCountdown();
        this.startSpin(targetNumber);
    }

    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    // üéÆ INPUT EVENT HANDLERS
    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    private handleInputSpin(targetNumber: number): void {
        if (this.canSpin()) {
            this.startSpin(targetNumber);
            console.log(`üéÆ Input spin to number ${targetNumber}`);
        }
    }

    private handleInputRandomSpin(): void {
        if (this.canSpin()) {
            const randomWinner = Math.floor(Math.random() * ROULETTE_CONFIG.pocketCount);
            this.startSpin(randomWinner);
            console.log(`üéÆ Input random spin to number ${randomWinner}`);
        }
    }

    private handleInputCountdownStart(seconds: number): void {
        if (!Globals.isProd) {
            this.gameUI.startCountdown(seconds, () => {
                console.log("Manual countdown completed!");
            });
            console.log(`üéÆ Input countdown started: ${seconds}s`);
        }
    }

    private handleInputCountdownStop(): void {
        if (!Globals.isProd) {
            this.gameUI.stopCountdown();
            console.log("üéÆ Input countdown stopped");
        }
    }

    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    // üéØ CORE GAME METHODS
    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    /**
     * üéØ Start roulette spin
     * @param winningNumber The target roulette number (0-36) where ball should land
     */
    private startSpin(winningNumber: number): void {
        if (!this.canSpin()) {
            console.warn("üéØ Cannot start spin - game not ready");
            return;
        }

        console.log(`üéØ Starting spin to NUMBER ${winningNumber} (not index!)`);
        this.isSpinning = true;
        this.updateGameState();
        
        // üîß FIX: No wheel synchronization - wheel rotates constantly like a real casino
        // Ball physics handles all timing to land when target number passes top position
        console.log(`üé∞ REAL CASINO MODE: Wheel continues constant rotation, ball must time itself perfectly`);
        
        // Start ball physics - ball is responsible for timing its landing
        this.ballPhysics.startSpin(winningNumber);
    }

    /**
     * üîç Check if game can accept new spins
     */
    private canSpin(): boolean {
        return !this.isSpinning && !this.gameUI.isCountdownRunning();
    }

    /**
     * üîÑ Update game state across all systems
     */
    private updateGameState(): void {
        this.inputController.updateGameState(
            this.isSpinning, 
            this.gameUI.isCountdownRunning(), 
        );
    }

    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    // üìã PUBLIC API METHODS
    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    public getIsSpinning(): boolean {
        return this.isSpinning;
    }

    public isReadyToSpin(): boolean {
        return this.canSpin();
    }

    public spin(targetNumber?: number): void {
        if (Globals.isProd) {
            console.log("üåê Server mode: Manual spin ignored");
            return;
        }

        if (targetNumber !== undefined && targetNumber >= 0 && targetNumber < ROULETTE_CONFIG.pocketCount) {
            this.handleInputSpin(targetNumber);
        } else {
            this.handleInputRandomSpin();
        }
    }

    public startCountdown(seconds: number, onComplete?: () => void): void {
        if (!Globals.isProd) {
            this.gameUI.startCountdown(seconds, onComplete);
        }
    }

    public stopCountdown(): void {
        this.gameUI.stopCountdown();
    }

    public isCountdownRunning(): boolean {
        return this.gameUI.isCountdownRunning();
    }

    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    // üîÑ SCENE LIFECYCLE METHODS
    // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

    public recievedMessage(msgType: string, msgParams: any): void {
        console.log("üì® Scene message:",{ msgType, msgParams});
    }

    public update(dt: number): void {
        // Update UI system
        this.gameUI.update(dt);
        
        // Update ball physics (ensures settled ball moves with wheel)
        this.ballPhysics.update(dt);
    }

    public resize(): void {
        super.resize();
        // this.roulette.resize();
    }

    /**
     * üóëÔ∏è Cleanup method - called when scene is destroyed
     */
    public destroyScene(): void {
        console.log('üóëÔ∏è Destroying MainScene and cleaning up all systems');
        
        // Destroy all modular systems
        if (this.ballPhysics) this.ballPhysics.destroy();
        if (this.gameUI) this.gameUI.destroy();
        if (this.networkManager) this.networkManager.destroy();
        if (this.inputController) this.inputController.destroy();
        if (this.wheelSync) this.wheelSync.destroy();

        // Call parent cleanup
        super.destroyScene();
        
        console.log('üóëÔ∏è MainScene destruction complete');
    }
}
